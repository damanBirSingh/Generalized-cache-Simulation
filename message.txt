#include<bits/stdc++.h>
using namespace std;

struct cache
    {
       int validBit;
       int tag;
       int data;

        cache(int validBit, int tag, int data)                                    
        : validBit(validBit), tag(tag), data(data) {}
    };

int miss = 0;
int hit = 0;

bool containsTag (deque<cache> qtemp, int atag)
{
    for(int i=0;i<qtemp.size();i++)
    {
        if(atag == qtemp[i].tag)
        return true;
    }
    return false;
}


 void set_Associative_Cache()
{
     int lwAdd[25] = {0x40,0x44,0x48,0x4C,0x70,0x74,0x78,0x7C,0x80,0x84,0x88,0x8C,0x90,0x94,0x98,0x9C,0x0,0x4,0x8,0xC,0x10,0x14,0x18,0x1C,0x20};
     int cacheSize,blockSize,setWay;
     int atag, setBits, offsetBits;
    cout<<"Enter Cache Size in words = ";
    cin>>cacheSize;
    cout<<"\n Enter Block Size in words = ";
    cin>>blockSize;
    cout<<"\nEnter Set way = ";
    cin>>setWay;
    int lines = ( cacheSize / blockSize);
    int NumberOfSet = (lines / setWay);

    offsetBits = log2(blockSize*4);
    setBits = log2(NumberOfSet);
   // cout<< lines;

    vector<deque<cache>> cacheSet(NumberOfSet, deque<cache>(setWay*blockSize, cache(0,0,0)));
   // vector<deque<cache>> cacheSet;
    int x = offsetBits + setBits;
    
    int n = 2;
    int count=0;
    
while(n--)
{
    //count++;
    for(int i=0;i<25;i++)
    {
        int address=0;
         int temp = blockSize;
        while(temp>0)
        {
            int whichSet = ((lwAdd[i]+address)>>offsetBits) & (NumberOfSet-1);
            atag = (lwAdd[i]+address) >> x;

          //  cout<<whichSet;

            if(cacheSet[whichSet][0].validBit == 1)
            {
                
                if(containsTag(cacheSet[whichSet], atag))
                {    
                    hit++;
                }
                else
                {
                    //count++;
                    miss++;
                    if(cacheSet[whichSet].size() < (setWay*blockSize))
                    {
                        cacheSet[whichSet].push_back(cache(1,atag,lwAdd[i]));
                    }
                    else
                    {
                       // int t = blockSize;
                        //count++;
                            cacheSet[whichSet].pop_front();  
                          
                        cacheSet[whichSet].push_back(cache(1,atag,lwAdd[i]));
                    }
                }
            }
            else
            {
                cacheSet[whichSet].pop_front();
               // count++;
                miss++;
                deque<cache> q;
                q.push_back(cache(1, atag , lwAdd[i]));
                cacheSet[whichSet] = q;
            }
           // for(int i=0;i<cacheSet[whichSet].size();i++)
            //{
              //  cout<<cacheSet[whichSet][i].tag;
            //}

            //cout<<whichSet;
            
          address=address+4;
          temp--;
        }
    }
    
}
   // miss = miss;
    cout<<miss;
    cout<<"\n";
   // float missrate = miss/10000;
  //  double misstemp = missrate*100;
   // cout<<missrate;
    //cout<<"\n";
   cout<<count<<"\n";
for(int i = 0;i<cacheSet.size();i++)
{
    for(int j=0;j<cacheSet[i].size();j++)
    {
        cout<<cacheSet[i][j].validBit<<" ";
        cout<<hex<<cacheSet[i][j].data<<" ";
        cout<<cacheSet[i][j].tag<<" ";
        cout<<"\n";
    }
}
}

int main()
{
    set_Associative_Cache();
  // cout<<miss<<" ";
    //cout<<hit;
    return 0;
}